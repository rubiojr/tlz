# Risor Language Reference Guide

## Core Syntax

### Variable Declaration
```risor
// Use := for variable declaration (not var keyword like in Go)
x := 10
y := "hello"
z := 3.14

// Constants
const URL = "https://example.com"

// Multiple variables need container initialization
a, b, c := [1, 2, 3]  // Not a = b = c = value
```

### Data Types
```risor
// Basic types
num := 42          // int
price := 19.99     // float
name := "Alice"    // string
active := true     // bool
nothing := nil     // nil

// Container types
items := [1, 2, 3]           // list
settings := {theme: "dark"}  // map (keys are always strings)
uniqueIds := {1, 2, 3}       // set
```

### String Handling
```risor
// Three types of strings:
standard := "Double quotes: standard strings"
template := 'Single quotes: support {variable} interpolation'
multiline := `Backticks: raw strings
that span multiple
lines`

name := "world"
greeting := 'Hello, {name}!'  // "Hello, world!"

// String methods
"hello".to_upper()            // "HELLO"
"  text  ".trim_space()       // "text"
"a,b,c".split(",")            // ["a", "b", "c"]
",".join(["a", "b", "c"])     // "a,b,c"
```

### Functions
```risor
// Basic function
func add(a, b) {
  return a + b
}

// Function with default parameter
func greet(name='world') {
  return 'Hello, {name}!'
}

// Functions as values
doubler := func(x) {
  return x * 2
}

// Functions can only return a single value
// Use containers for multiple return values
func get_user_info() {
  return {name: "Alice", age: 30}
}

// Unpacking
info := get_user_info()
print(info.name)
```

### Control Flow
```risor
// If-else as expression
status := if x > 10 {
  "greater"
} else if x == 10 {
  "equal"
} else {
  "lesser"
}

// Switch as expression
role := switch name {
  case "admin":
    "Administrator"
  case "mod":
    "Moderator"
  default:
    "User"
}

// Loops
for i := 0; i < 5; i++ {
  print(i)
}

for i := range 5 {
  print(i)
}

i := 0
for i < 5 {
  print(i)
  i++
}

list := [1, 2, 3]
for i, value := range list {
  print(i, value)
}

// Ternary expression
allowed := age >= 18 ? true : false
```

## Error Handling

```risor
// Raising errors
func divide(a, b) {
  if b == 0 {
    error("division by zero")
  }
  return a / b
}

// Try function for error handling
result := try(
  func() {
    return divide(10, 0)
  },
  "division failed"
)  // result is "division failed"

// Chaining fallbacks
result := try(
  func() { error("first error") },
  func() { error("second error") },
  "default value"
)  // result is "default value"

// Access the error in fallback
result := try(
  func() {
    error("something failed")
  },
  func(err) {
    print("Error caught:", err)
    return "recovered"
  }
)
```

## Pipe Operator

```risor
// Pipe operator passes the left value as first argument to the right function
"hello" | strings.to_upper                 // "HELLO"
[1, 2, 3] | math.sum                       // 6

// Chain pipes
"  hello  " | strings.trim_space | strings.to_upper  // "HELLO"

// Process data pipeline style
fetch("https://api.example.com/users")
  | .json()
  | jmespath("[].name")
```

## Modules and Imports

```risor
// Import module (no quotes)
import math
import time

// Import with alias
import strings as str

// Import specific attributes
from os import read_file, write_file

// Using imported modules
math.sqrt(16)
str.to_upper("hello")
```

## Concurrency

```risor
// Channels
c := chan(1)    // Buffered channel with capacity 1
c <- "hello"    // Send value
x := <-c        // Receive value
close(c)        // Close channel

// Range over channel (different from Go)
for i, value := range c {
  print(i, value)  // i is the index
}

// Goroutines
go func() {
  // Run in background
  time.sleep(1)
  print("background task completed")
}()

// Spawn and wait for result
result := spawn(func(x) {
  time.sleep(1)
  return x * 2
}, 21).wait()   // result is 42
```

## Built-ins and Common Modules

### Key Built-ins
```risor
print("Output to console")           // Print to stdout
len([1, 2, 3])                       // Length of container (3)
assert(x > 0, "must be positive")    // Assertion with message
type([1, 2])                         // Returns "list"
keys({a: 1, b: 2})                   // Returns ["a", "b"]
```

### HTTP Operations
```risor
// Simple HTTP request
response := fetch("https://api.example.com")
status := response.status_code  // e.g., 200
data := response.json()         // Parse JSON response

// Request with options
response := fetch("https://api.example.com", {
  method: "POST",
  headers: {"Content-Type": "application/json"},
  data: {name: "Alice", age: 30}
})
```

### File Operations
```risor
// Read/write files
content := os.read_file("config.json")
os.write_file("output.txt", "Hello, world!")

// Directory operations
files := os.read_dir("/tmp")
os.mkdir("new_directory", 0755)
path := filepath.join("path", "to", "file.txt")
```

### JSON and YAML
```risor
// JSON operations
json_str := json.marshal({name: "Alice", age: 30})
obj := json.unmarshal('{"name": "Bob", "age": 25}')

// YAML operations
yaml_str := yaml.marshal({name: "Alice", age: 30})
obj := yaml.unmarshal("name: Bob\nage: 25")
```

### Time and Date
```risor
// Time operations
now := time.now()
formatted := now.format(time.RFC3339)
time.sleep(0.5)  // Sleep for 0.5 seconds
```

## Complete Examples

### HTTP API Client
```risor
import os

// Function to fetch user data
func get_user(id) {
  response := try(
    func() {
      return fetch('https://api.example.com/users/{id}')
    },
    func(err) {
      print("Request failed:", err)
      return nil
    }
  )

  if response == nil {
    return nil
  }

  if response.status_code != 200 {
    print("Error:", response.status_code)
    return nil
  }

  return response.json()
}

// Process and save user data
user := get_user(42)
if user != nil {
  print('Found user: {user.name}')
  os.write_file("user_data.json", json.marshal(user))
}
```

### Concurrent File Processing
```risor
import os
import filepath

func process_file(path) {
  content := try(
    func() { return os.read_file(path) },
    func(err) {
      print('Error reading {path}:', err)
      return nil
    }
  )

  if content == nil {
    return nil
  }

  // Process content (e.g., count lines)
  lines := strings.split(string(content), "\n")
  return len(lines)
}

// Process multiple files concurrently
files := os.read_dir(".")
threads := []

for _, file := range files {
  if filepath.ext(file.name) == ".txt" {
    threads.append(spawn(process_file, file.name))
  }
}

// Collect results
results := {}
for i, thread := range threads {
  path := files[i].name
  results[path] = thread.wait()
}

print("Results:", results)
# Important rules when writing Risor code
- Use two spaces to indent code
- No `var` keyword for variables (use `:=`)
- No `??` operator for null coalescing (use `coalesce()` function)
- Module imports don't use quotes. Use `import math` and not not `import "math"`
- Use single quotes for string interpolation: `'Hello, {name}'`
- If-else and switch are expressions that return values
- String interpolation with single quotes only supports simple variable substitution (`'{variable}'`). It does not support formatting specifications inside the curly braces like Python's f-strings. To format values, use the `fmt.sprintf()` function separately and concatenate the results
- ^ is not a valid power operator in Risor. Use math.pow() function instead
- Use os.stdin.input() to read input from the user

Always follow the above rules.
# Errors Module Summary
Errors module provides functions for creating error values in Risor.
## Functions
* new(string) - Creates a new error value with the given message

# Exec Module Summary
Exec module is used to run external commands without invoking the system shell.
## Functions
* exec(args, opts) - Runs command and returns result object
* command(args) - Creates a new command
* look_path(name) - Searches for executable in PATH
## Types
* command - Has path, dir, env, stdout, stderr attributes and run(), output(), combined_output(), start(), wait() methods
* result - Has stdout, stderr, pid attributes

# Filepath Module Summary
Filepath module provides utilities to manipulate file paths with OS-specific separators.
## Functions
* abs(path) - Returns absolute representation of path
* base(path) - Returns last element of path
* clean(path) - Returns shortest path name equivalent
* dir(path) - Returns all but last element of path
* ext(path) - Returns file extension
* is_abs(path) - Checks if path is absolute
* join(paths...) - Joins path elements with OS-specific separator
* match(pattern, name) - Checks if filename matches shell pattern
* rel(basepath, targpath) - Returns relative path from base to target
* split_list(path) - Splits path into directory and file components as list
* split(path) - Splits path into directory and file components
* walk_dir(root, fn) - Walks file tree calling function for each entry
# HTTP Module Summary
HTTP module provides functions for making HTTP requests and handling responses.
## Functions
* get(url, headers, params) - Creates a GET request
* delete(url, headers, params) - Creates a DELETE request
* head(url, headers, params) - Creates a HEAD request
* listen_and_serve(addr, handler) - Starts an HTTP server
* listen_and_serve_tls(addr, cert_file, key_file, handler) - Starts an HTTPS server
* patch(url, headers, body) - Creates a PATCH request
* post(url, headers, body) - Creates a POST request
* put(url, headers, body) - Creates a PUT request
* request(url, options) - Creates a custom HTTP request
## Types
* request - Has url, content_length, header attributes and send(), add_header(), add_cookie(), set_body(), set_data() methods
* response - Has status, status_code, proto, content_length, header, cookies, response attributes and json(), text(), close() methods
* response_writer - Has add_header(), del_header(), write(), write_header() methods
# Math Module Summary
Math module provides constants and mathematical functions, wrapping Go's math package with additional utilities.
## Constants
* PI - Mathematical constant pi (3.141592653589793)
* E - Mathematical constant e (2.718281828459045)
## Functions
* abs(x) - Returns absolute value
* sqrt(x) - Returns square root
* min(x, y) - Returns smaller of two numbers
* max(x, y) - Returns larger of two numbers
* floor(x) - Returns largest integer less than or equal to x
* ceil(x) - Returns smallest integer greater than or equal to x
* sin(x) - Returns sine
* cos(x) - Returns cosine
* tan(x) - Returns tangent
* mod(x, y) - Returns remainder of division
* log(x) - Returns natural logarithm
* log10(x) - Returns base-10 logarithm
* log2(x) - Returns base-2 logarithm
* pow(x, y) - Returns x raised to power of y
* pow10(x) - Returns 10 raised to power of x
* is_inf(x) - Checks if value is infinity
* inf() - Returns infinite value
* round(x) - Rounds to nearest integer
* sum(list) - Returns sum of all numbers in list
# OS Module Summary
OS module provides platform-independent access to operating system functionality.
## Attributes
* stdin - Standard input file pointer
* stdout - Standard output file pointer
## Functions
* chdir(dir) - Changes working directory
* create(name) - Creates or truncates a file
* environ() - Returns environment variables as list of strings
* exit(code) - Terminates program with exit code
* getenv(key) - Gets environment variable value
* getpid() - Returns current process ID
* getuid() - Returns current user ID
* getwd() - Gets current working directory
* hostname() - Returns system hostname
* mkdir_all(path, perm) - Creates directory with parents
* mkdir_temp(dir, prefix) - Creates temporary directory
* mkdir(path, perm) - Creates directory
* open(name) - Opens file for reading
* read_dir(name) - Lists directory contents
* read_file(name) - Reads file contents
* remove(name) - Removes file or empty directory
* remove_all(name) - Removes directory and contents
* rename(old, new) - Renames/moves file or directory
* setenv(key, value) - Sets environment variable
* stat(name) - Returns file information
* symlink(old, new) - Creates symbolic link
* temp_dir() - Returns temporary directory path
* unsetenv(key) - Unsets environment variable
* user_cache_dir() - Returns user cache directory
* user_config_dir() - Returns user config directory
* user_home_dir() - Returns user home directory
* write_file(name, data) - Writes data to file
## Types
* File - Has read(), write(), close() methods
* FileInfo - Contains name, mode, size, mod_time attributes
* DirEntry - Contains name, type attributes
# regexp Module Summary
The regexp module provides regular expression matching functionality using Go's regexp syntax.
## Functions
- `compile(expr string)` - Compiles a regular expression string
- `match(expr, s string)` - Tests if a string contains a pattern match
## Types
- `regexp` - Represents a compiled regular expression
- `match(s string)` - Tests if string contains pattern match
- `find(s string)` - Returns leftmost match
- `find_all(s string)` - Returns all matches
- `find_submatch(s string)` - Returns matches and submatches
- `replace_all(s, repl string)` - Replaces all matches with replacement
- `split(s string)` - Splits string by pattern matches
# Strings Module Summary
String manipulation functions from the Go standard library.
## Functions
* compare(s1, s2) - Compares strings lexicographically
* contains(s, substr) - Checks if string contains substring
* count(s, substr) - Counts non-overlapping instances of substring
* fields(s) - Splits string on whitespace
* has_prefix(s, prefix) - Checks if string starts with prefix
* has_suffix(s, suffix) - Checks if string ends with suffix
* index(s, substr) - Returns first index of substring or -1
* join(a, sep) - Concatenates strings with separator
* last_index(s, substr) - Returns last index of substring or -1
* repeat(s, count) - Creates new string with repeated copies
* replace_all(s, old, new) - Replaces all instances of old with new
* split(s, sep) - Splits string on separator
* to_lower(s) - Converts string to lowercase
* to_upper(s) - Converts string to uppercase
* trim_prefix(s, prefix) - Removes leading prefix if present
* trim_space(s) - Removes leading and trailing whitespace
* trim_suffix(s, suffix) - Removes trailing suffix if present
* trim(s, cutset) - Removes leading and trailing characters in cutset
# Time Module Summary
Time module provides functionality for measuring and displaying time.
## Constants
* ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, RFC3339, RFC3339Nano, Kitchen, Stamp, StampMilli, StampMicro, StampNano - Predefined date/time formats
## Functions
* now() - Returns current time
* unix(sec, nsec) - Returns time from Unix timestamp
* parse(layout, value) - Parses string into time object
* since(t) - Returns seconds elapsed since given time
* sleep(duration) - Pauses execution for specified seconds
## Types
* time - Has before(t), after(t), format(layout), utc(), unix() methods
import { Callout } from 'nextra/components';

# cli

Module `cli` is used to build command line apps written in the Risor. Common
CLI features are supported, including commands, flags, arguments, usage, and
automatic help generation.

<Callout type="info" emoji="ℹ️">
  This module is included by default in the Risor CLI, but must be
  independently installed when using Risor as
  a library using `go get github.com/risor-io/risor/modules/cli`
</Callout>

Behind the scenes, this module uses the [urfave/cli](https://cli.urfave.org/) library.

## Getting Started

Create a file named `myapp.risor` with the following contents. Note that you
must include the shebang line including `--` at the top of the file to ensure
that arguments and options are _passed to the app_, rather than being used as
options by the Risor binary itself.

```risor copy filename="myapp.risor"
#!/usr/bin/env risor --

from cli import app, command as c

app({
    name: "myapp",
    description: "My app description",
    commands: [
        c({
            name: "hello",
            description: "Say hello",
            action: func(ctx) {
                print("Hello, world!")
            },
        }),
    ],
}).run()
```

Now make the file executable:

```
$ chmod +x ./myapp.risor
```

You can now run the app as follows:

```
$ ./myapp.risor hello
Hello, world!
```

## Functions

### app

```go filename="Function signature"
app(options map) app
```

Returns a new app initialized with the given options. A simple app may consist
of just a `name`, `description`, and `action` function. Call `.run()` on the
app to run it.

```risor copy filename="Example"
app := cli.app({
    name: "myapp",
    description: "My app description",
    action: func(ctx) {
        print("Hello, world!")
    },
})

app.run()
```

The `app` function supports the following options:

- `action func(ctx)`: The action to run when the app is run.
- `args bool`: Whether this app supports arguments.
- `args_usage string`: Description of the program argument format.
- `commands []cli.command`: A list of commands that the app supports.
- `default_command string`: Name of a command to run if no command names are passed as CLI arguments.
- `description string`: A short description of the app.
- `enable_bash_completion bool`: Enable bash completion commands.
- `flags []cli.flag`: A list of flags that the app supports.
- `help_name string`: Override for the name of the app in help output.
- `hide_help bool`: Hide built-in help command and help flag.
- `hide_help_command bool`: Hide built-in help command but keep help flag (ignored if hide_help is true).
- `hide_version bool`: Hide built-in version flag and VERSION section of help.
- `name string`: The name of the app.
- `usage_text string`: Text to override the USAGE section of help.
- `usage string`: The usage string for the app.
- `version string`: The version of the app.

### command

```go filename="Function signature"
command(options map) command
```

Returns a new command initialized with the given options. Commands are provided
to an app via the app's `commands` option.

```go copy filename="Example"
command := cli.command({
    name: "add",
    description: "Add numbers provided as arguments",
    action: func(ctx) {
        sum := 0
        for _, arg := range ctx.args() {
            sum += int(arg)
        }
        print(sum)
    },
})
```

The `command` function supports the following options:

- `action func(ctx)`: The function to call when the command is invoked.
- `aliases []string`: A list of aliases for the command.
- `args_usage string`: A short description of the arguments of this command.
- `args bool`: Whether this command supports arguments.
- `category string`: The category the command is part of.
- `custom_help_template string`: Text template for the command help topic.
- `description string`: A longer explanation of how the command works.
- `flags []cli.flag`: A list of flags that the command supports.
- `help_name string`: Full name of command for help, defaults to full command name, including parent commands.
- `hidden bool`: Hide this command from help or completion.
- `hide_help_command bool`: Whether to hide the command from the help command.
- `hide_help bool` Hide the built-in help command and help flag.
- `name string`: The name of the command.
- `usage_text string`: Custom text to show in USAGE section of help.
- `usage string`: A short description of the usage of this command.
- `use_short_option_handling bool`: Enables short-option handling so the user can combine several single-character bool flags into one.

### flag

```go filename="Function signature"
flag(options map) flag
```

Returns a flag that may be used with an app or command. Supported flag types
include `string`, `int`, `bool`, `float`, `string_slice`, `int_slice`,
and `float_slice`.

A default value for the flag may be provided using the `value` option. The flag
type is inferred from the `value` option if a `type` is not specified.

```go copy filename="Example string flag"
cli.flag({
    name: "food",
    aliases: ["f"],
    usage: "The type of food to eat",
    env_vars: ["FOOD"], // read from this environment variable, if present
    value: "pizza",     // default value
    type: "string",     // flag type: string, int, bool, etc.
})
```

```go copy filename="Example int flag"
cli.flag({
    name: "count",
    aliases: ["c"],
    usage: "The number of items to process",
    value: 1,
})
```

```go copy filename="Example bool flag"
cli.flag({
    name: "verbose",
    aliases: ["v"],
    usage: "Enable verbose output",
    value: false,
})
```

## Types

### app

An app represents the main entry point for a command-line program. It contains
commands, is customized with flags, and is executed via `app.run()`.

### ctx

A ctx object is passed through to each handler action in a cli app. It is
used to retrieve context-specific args and parsed command-line options.

Attributes on the ctx object include:

| Name             | Type                         | Description                                                             |
| ---------------- | ---------------------------- | ----------------------------------------------------------------------- |
| args             | func() []string              | Returns the command-line arguments                                      |
| narg             | func() int                   | Returns the number of arguments                                         |
| value            | func(name string) object     | Returns the value of the flag corresponding to `name`                   |
| count            | func(name string) int        | Returns the count of the flag corresponding to `name`                   |
| flag_names       | func() []string              | Returns the names of all flags used by this context and parent contexts |
| local_flag_names | func() []string              | Returns the names of all flags used by this context                     |
| is_set           | func(name string) bool       | Returns true if the flag corresponding to `name` is set                 |
| set              | func(name string, value obj) | Sets the value of the flag corresponding to `name`                      |
| num_flags        | func() int                   | Returns the number of flags set                                         |
| bool             | func(name string) bool       | Returns the value of the bool flag corresponding to `name`              |
| int              | func(name string) int        | Returns the value of the int flag corresponding to `name`               |
| string           | func(name string) string     | Returns the value of the string flag corresponding to `name`            |
| string_slice     | func(name string) []string   | Returns the value of the string slice flag corresponding to `name`      |

### command

A command represents a sub-command of an app. It contains its own flags and
has an associated action. Commands may have sub-commands.

### flag

A flag is used to parse command-line flags in a cli app. Flags may be specified
on a cli app directly, as well as on commands.
